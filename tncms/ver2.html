<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analizzatore di Log Avanzato</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <!-- Main Container -->
    <div class="flex flex-col lg:flex-row gap-8 max-w-7xl mx-auto min-h-screen">

        <!-- Sidebar for Filters and Actions -->
        <div class="lg:w-1/4 w-full bg-white shadow-xl rounded-2xl p-6 h-fit sticky top-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">Controlli</h2>
            
            <!-- Log Input Section -->
            <div class="mb-6">
                <label for="logInput" class="block text-gray-700 font-semibold mb-2">Incolla i tuoi log:</label>
                <textarea id="logInput" rows="10" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" placeholder="Incolla i tuoi log qui..."></textarea>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col gap-4 mb-8">
                <button id="analyzeBtn" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-full shadow-lg hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300">
                    Analizza e Carica
                </button>
                <button id="resetBtn" class="bg-gray-200 text-gray-700 font-bold py-3 px-6 rounded-full shadow-lg hover:bg-gray-300 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-300">
                    Resetta Tutto
                </button>
            </div>

            <hr class="border-gray-200 mb-6">

            <!-- Dynamic Filters Section -->
            <div id="filterSection" class="hidden">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Filtri dinamici</h3>
                <div id="filterControls" class="space-y-4">
                    <!-- Dynamic filters will be appended here -->
                </div>
            </div>

            <hr id="filterDivider" class="border-gray-200 mt-6 hidden">

            <!-- Grouping Options -->
            <div id="groupingSection" class="hidden mt-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Raggruppa per...</h3>
                <select id="groupingSelect" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                    <option value="">Nessun raggruppamento</option>
                    <!-- Grouping options will be dynamically added here -->
                </select>
            </div>

        </div>

        <!-- Main Content Area -->
        <div class="lg:w-3/4 w-full bg-white shadow-xl rounded-2xl p-6">
            <h1 class="text-4xl font-bold text-gray-800 mb-6 text-center">Analizzatore di Log</h1>

            <!-- Message Box for Alerts -->
            <div id="messageBox" class="hidden fixed top-5 left-1/2 -translate-x-1/2 p-4 rounded-lg shadow-xl text-white font-semibold transition-opacity duration-300 z-50"></div>

            <!-- Loading Indicator -->
            <div id="loadingIndicator" class="hidden text-center text-gray-500 my-8">
                <div class="inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-current border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]" role="status">
                    <span class="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">Loading...</span>
                </div>
                <p class="mt-2">Analisi in corso...</p>
            </div>

            <!-- Results Section -->
            <div id="resultsContainer" class="hidden">
                <!-- Log Counts -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4 mb-6">
                    <div class="bg-blue-100 p-6 rounded-xl shadow-md text-center">
                        <p class="text-gray-700 text-lg">Righe di log totali:</p>
                        <p id="totalLogsCount" class="text-4xl font-bold text-blue-600 mt-2">0</p>
                    </div>
                    <div class="bg-red-100 p-6 rounded-xl shadow-md text-center">
                        <p class="text-gray-700 text-lg">Errori filtrati:</p>
                        <p id="filteredErrorsCount" class="text-4xl font-bold text-red-600 mt-2">0</p>
                    </div>
                </div>

                <!-- Grouped Summary -->
                <div id="summarySection" class="bg-gray-50 p-6 rounded-2xl shadow-inner mb-6">
                    <h2 id="summaryTitle" class="text-3xl font-bold text-gray-800 mb-4 text-center">Riepilogo Dati</h2>
                    <div id="summaryResults">
                        <p class="text-gray-500 italic text-center">Seleziona un'opzione di raggruppamento per visualizzare il riepilogo.</p>
                    </div>
                </div>

                <!-- Raw Log Display -->
                <div id="logDisplaySection" class="mt-8">
                    <h2 class="text-3xl font-bold text-gray-800 mb-4 text-center">Log Filtrati</h2>
                    <div id="filteredLogs" class="bg-gray-800 text-gray-50 p-6 rounded-xl shadow-inner overflow-x-auto whitespace-pre-wrap font-mono text-sm">
                        <!-- Filtered logs will be displayed here -->
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // State variables
            let allLogs = [];
            let filteredLogs = [];
            let uniqueKeys = new Set();
            let currentFilters = {};
            let currentGrouping = '';

            // Get DOM elements
            const logInput = document.getElementById('logInput');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const resetBtn = document.getElementById('resetBtn');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const resultsContainer = document.getElementById('resultsContainer');
            const messageBox = document.getElementById('messageBox');
            const filterSection = document.getElementById('filterSection');
            const filterControls = document.getElementById('filterControls');
            const filterDivider = document.getElementById('filterDivider');
            const groupingSection = document.getElementById('groupingSection');
            const groupingSelect = document.getElementById('groupingSelect');
            const summarySection = document.getElementById('summarySection');
            const summaryTitle = document.getElementById('summaryTitle');
            const summaryResults = document.getElementById('summaryResults');
            const totalLogsCount = document.getElementById('totalLogsCount');
            const filteredErrorsCount = document.getElementById('filteredErrorsCount');
            const filteredLogsDisplay = document.getElementById('filteredLogs');

            // --- Event Listeners ---

            analyzeBtn.addEventListener('click', () => {
                const logs = logInput.value.trim();
                if (!logs) {
                    showMessage('Per favore, incolla prima i tuoi log.', 'bg-yellow-500');
                    return;
                }

                showLoading(true);
                // Simulate a small delay for a better UX
                setTimeout(() => {
                    try {
                        allLogs = parseLogs(logs);
                        if (allLogs.length > 0) {
                            extractUniqueKeys(allLogs);
                            renderFilterControls();
                            renderGroupingOptions();
                            applyFilters(); // Initial render
                            resultsContainer.classList.remove('hidden');
                            filterSection.classList.remove('hidden');
                            filterDivider.classList.remove('hidden');
                            groupingSection.classList.remove('hidden');
                            showMessage('Analisi completata con successo!', 'bg-green-500');
                        } else {
                            showMessage('Nessun log valido trovato.', 'bg-red-500');
                            resetApp();
                        }
                    } catch (error) {
                        console.error('Error during log analysis:', error);
                        showMessage('Si Ã¨ verificato un errore durante l\'analisi.', 'bg-red-500');
                        resetApp();
                    } finally {
                        showLoading(false);
                    }
                }, 500);
            });

            resetBtn.addEventListener('click', resetApp);
            groupingSelect.addEventListener('change', (e) => {
                currentGrouping = e.target.value;
                renderSummary();
            });

            // Handle filter changes via event delegation
            filterControls.addEventListener('change', (e) => {
                const target = e.target;
                if (target.tagName === 'SELECT') {
                    const key = target.dataset.key;
                    const value = target.value;
                    if (value) {
                        currentFilters[key] = value;
                    } else {
                        delete currentFilters[key];
                    }
                    applyFilters();
                }
            });

            // --- Core Functions ---

            /**
             * Parses raw log text into an array of structured log objects.
             * @param {string} logs - The raw log string.
             * @returns {Array<Object>} An array of parsed log objects.
             */
            function parseLogs(logs) {
                const lines = logs.split('\n').filter(line => line.trim() !== '');
                const parsedData = [];

                // Regex to capture the syslog header and the rest of the message
                const mainRegex = /^(\w{3}\s+\d+\s+\d{2}:\d{2}:\d{2})\s+([\d.]+)\s+([^:]+):(?:\s+\[logsplit=\|-\|\])?\s+(.*)/;
                // Regex to capture key-value pairs
                const kvRegex = /\[([^=]+)=([^\]]+)\]/g;

                lines.forEach(line => {
                    const mainMatch = line.match(mainRegex);
                    if (mainMatch) {
                        const [, timestamp, ip, service, messagePart] = mainMatch;
                        const logEntry = {
                            fullLine: line.trim(),
                            timestamp: timestamp.trim(),
                            ip: ip.trim(),
                            service: service.trim()
                        };

                        let kvMatch;
                        let remainingMessage = messagePart;
                        
                        // Extract all key-value pairs
                        while ((kvMatch = kvRegex.exec(messagePart)) !== null) {
                            const key = kvMatch[1].trim();
                            const value = kvMatch[2].trim();
                            logEntry[key] = value;
                            remainingMessage = remainingMessage.replace(kvMatch[0], '').trim();
                        }

                        // The remaining part of the message is the primary log message
                        if (logEntry.message) {
                            // If a message key was found, its value is the main message
                            logEntry.message = logEntry.message;
                        } else {
                            // Otherwise, the remaining string is the main message
                            logEntry.message = remainingMessage.split('#0')[0].trim();
                        }
                        
                        // Add the stack trace if it exists
                        const stackTraceMatch = messagePart.match(/#0\s+\[internal function\]:.*$/);
                        if (stackTraceMatch) {
                            logEntry.stackTrace = stackTraceMatch[0];
                        }

                        parsedData.push(logEntry);
                    }
                });
                return parsedData;
            }
            
            /**
             * Extracts all unique keys from the log data to build filters and grouping options.
             * @param {Array<Object>} logs - The array of parsed log objects.
             */
            function extractUniqueKeys(logs) {
                uniqueKeys.clear();
                logs.forEach(log => {
                    Object.keys(log).forEach(key => {
                        if (!['fullLine', 'timestamp'].includes(key)) {
                            uniqueKeys.add(key);
                        }
                    });
                });
            }

            /**
             * Renders the dynamic filter dropdowns based on the extracted unique keys.
             */
            function renderFilterControls() {
                filterControls.innerHTML = '';
                const sortedKeys = [...uniqueKeys].sort();

                sortedKeys.forEach(key => {
                    const values = new Set();
                    allLogs.forEach(log => {
                        if (log[key]) {
                            values.add(log[key]);
                        }
                    });

                    if (values.size > 1 || ['level'].includes(key)) {
                        const div = document.createElement('div');
                        div.className = 'mb-4';
                        
                        const label = document.createElement('label');
                        label.className = 'block text-gray-700 font-medium mb-1';
                        label.textContent = key.charAt(0).toUpperCase() + key.slice(1);
                        div.appendChild(label);

                        const select = document.createElement('select');
                        select.id = `filter-${key}`;
                        select.dataset.key = key;
                        select.className = 'w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500';
                        
                        const defaultOption = document.createElement('option');
                        defaultOption.value = '';
                        defaultOption.textContent = `Tutti i valori`;
                        select.appendChild(defaultOption);

                        [...values].sort().forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            select.appendChild(option);
                        });

                        div.appendChild(select);
                        filterControls.appendChild(div);
                    }
                });
            }

            /**
             * Renders the grouping options in the dropdown.
             */
            function renderGroupingOptions() {
                groupingSelect.innerHTML = '<option value="">Nessun raggruppamento</option>';
                const sortedKeys = [...uniqueKeys].sort();
                sortedKeys.forEach(key => {
                    if (key !== 'fullLine' && key !== 'stackTrace') {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = key.charAt(0).toUpperCase() + key.slice(1);
                        groupingSelect.appendChild(option);
                    }
                });
            }

            /**
             * Applies the current filters to the full log data and updates the UI.
             */
            function applyFilters() {
                filteredLogs = allLogs.filter(log => {
                    return Object.keys(currentFilters).every(key => {
                        return log[key] === currentFilters[key];
                    });
                });

                // Update total log count and filtered errors count
                totalLogsCount.textContent = filteredLogs.length;
                filteredErrorsCount.textContent = filteredLogs.filter(log => log.level === 'error').length;
                
                // Render the filtered logs and the summary
                renderFilteredLogs();
                renderSummary();
            }

            /**
             * Renders the grouped summary based on the current grouping selection.
             */
            function renderSummary() {
                summaryResults.innerHTML = '';
                if (!currentGrouping) {
                    summaryResults.innerHTML = '<p class="text-gray-500 italic text-center">Seleziona un\'opzione di raggruppamento per visualizzare il riepilogo.</p>';
                    return;
                }

                summaryTitle.textContent = `Riepilogo raggruppato per: ${currentGrouping.charAt(0).toUpperCase() + currentGrouping.slice(1)}`;
                
                const counts = countOccurrences(filteredLogs, currentGrouping);
                
                const list = document.createElement('ul');
                list.className = 'divide-y divide-gray-200';
                
                if (counts.length === 0) {
                    const noData = document.createElement('li');
                    noData.className = 'py-2 text-gray-500 italic text-center';
                    noData.textContent = 'Nessun dato da mostrare.';
                    list.appendChild(noData);
                } else {
                    counts.forEach(([key, count]) => {
                        const listItem = document.createElement('li');
                        listItem.className = 'py-4 flex items-center justify-between transition-colors hover:bg-gray-100 rounded-lg px-2';
                        
                        const text = document.createElement('span');
                        text.className = 'flex-1 text-gray-700 break-all pr-4';
                        text.textContent = key;
                        
                        const countBadge = document.createElement('span');
                        countBadge.className = 'bg-blue-100 text-blue-800 font-bold px-3 py-1 rounded-full text-sm shrink-0';
                        countBadge.textContent = count;
                        
                        listItem.appendChild(text);
                        listItem.appendChild(countBadge);
                        list.appendChild(listItem);
                    });
                }
                summaryResults.appendChild(list);
            }

            /**
             * Renders the raw filtered log text.
             */
            function renderFilteredLogs() {
                const logText = filteredLogs.map(log => log.fullLine).join('\n');
                filteredLogsDisplay.textContent = logText || 'Nessun log corrisponde ai filtri attuali.';
            }

            /**
             * Counts the occurrences of a specific property in an array of logs.
             * @param {Array<Object>} logs - The array of parsed log objects.
             * @param {string} property - The property to count.
             * @returns {Array<[string, number]>} A sorted array of key-value pairs.
             */
            function countOccurrences(logs, property) {
                const counts = {};
                logs.forEach(log => {
                    const value = log[property];
                    if (value) {
                        counts[value] = (counts[value] || 0) + 1;
                    }
                });
                return Object.entries(counts).sort(([, countA], [, countB]) => countB - countA);
            }
            
            /**
             * Resets the entire application state and UI.
             */
            function resetApp() {
                allLogs = [];
                filteredLogs = [];
                uniqueKeys.clear();
                currentFilters = {};
                currentGrouping = '';
                logInput.value = '';
                filterControls.innerHTML = '';
                groupingSelect.innerHTML = '<option value="">Nessun raggruppamento</option>';
                summaryResults.innerHTML = '<p class="text-gray-500 italic text-center">Seleziona un\'opzione di raggruppamento per visualizzare il riepilogo.</p>';
                filteredLogsDisplay.textContent = '';
                totalLogsCount.textContent = '0';
                filteredErrorsCount.textContent = '0';
                resultsContainer.classList.add('hidden');
                filterSection.classList.add('hidden');
                filterDivider.classList.add('hidden');
                groupingSection.classList.add('hidden');
                showMessage('Applicazione resettata.', 'bg-gray-500');
            }

            /**
             * Shows or hides the loading indicator.
             * @param {boolean} isVisible - True to show, false to hide.
             */
            function showLoading(isVisible) {
                loadingIndicator.classList.toggle('hidden', !isVisible);
                analyzeBtn.disabled = isVisible;
                resetBtn.disabled = isVisible;
            }

            /**
             * Shows a temporary message box at the top of the screen.
             * @param {string} message - The message to display.
             * @param {string} bgColorClass - Tailwind class for background color.
             */
            function showMessage(message, bgColorClass) {
                messageBox.textContent = message;
                messageBox.className = `${bgColorClass} fixed top-5 left-1/2 -translate-x-1/2 p-4 rounded-lg shadow-xl text-white font-semibold transition-opacity duration-300 z-50`;
                messageBox.classList.remove('hidden');

                setTimeout(() => {
                    messageBox.classList.add('opacity-0');
                    setTimeout(() => {
                        messageBox.classList.add('hidden');
                        messageBox.classList.remove('opacity-0');
                    }, 300);
                }, 3000);
            }
        });
    </script>
</body>
</html>
